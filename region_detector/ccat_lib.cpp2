#include <boost/make_shared.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/program_options/errors.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/foreach.hpp>

#include <stdexcept>
#include <fstream>
#include "parser/readsParser.h"
#include "utils/exceptions.h"
#include "parser/bowtieParser.h"
#include "parser/samParser.h"
#include "parser/bamParser.h"
#include "parser/bedParser.h"
#include "option_parser/cmd_option_parser.h"
#include "option_parser/peakranger_cmd_option_parser.h"
#include "region_detector/region_detector.h"
#include "region_detector/calledpeak.h"
#include "region_detector/fdr_based_thresholder.h"
#include "region_detector/ccat.h"
#include "region_detector/chip4c.h"
#include "result_reporter/result_reporter.h"
#include "result_reporter/bed6_result_reporter.h"
#include "wiggle/wiggle_reporter.h"
#include "wiggle/JTwigglefile.h"

#include "utils/logger.h"
#include "utils/timer.h"
#include "utils/signaldumper.h"
#include "utils/stringutil.h"
#include "utils/util_print.h"
#include "short_reads/readstools.h"

#include "ggplay/chipseqhtmlreporter.h"

using namespace std;
using namespace boost;
#define foreach BOOST_FOREACH

typedef map<string, vector<called_peak> > enriched_regions;
typedef vector<called_peak>::iterator ritrr;
typedef enriched_regions::iterator pritrr;
namespace {
bool sorter_by_pval(called_peak r1, called_peak r2) {
    return r1.p < r2.p;
}

bool containsChr(enriched_regions& result, string& chr) {
    enriched_regions::iterator it;
    if (result.find(chr) == result.end()) {
        return false;
    }
    return true;
}

void OutputResults(peakranger_cmd_option_parser & option,
        boost::shared_ptr<region_detector> & detector, size_t & fdr_passed,
        size_t & fdr_failed) {
    string ga;
    ga = (option.getOutput_file() + "_region.bed");
    ofstream of(ga.c_str());
    if (!(of.is_open())) {
        throw FileNotGood(ga.c_str());
    }
    ga = (option.getOutput_file() + "_summit.bed");
    ofstream of_smt(ga.c_str());
    if (!(of_smt.is_open())) {
        throw FileNotGood(ga.c_str());
    }
    ga = (option.getOutput_file() + "_details");
    ofstream of_raw(ga.c_str());
    if (!(of_raw.is_open())) {
        throw FileNotGood(ga.c_str());
    }
    utilprint::citation ct;
    ct.print_msg(of_raw);
    ct.print_msg(of_smt);
    ct.print_msg(of);
    logDate(of_raw);
    logDate(of_smt);
    logDate(of);
    option.print_option_file(of_raw);
    option.print_option_file(of_smt);
    option.print_option_file(of);
    of_smt
            << "\n#summit_chr\tsummit_start\tsummit_end\tsummit_ID\tsummit_FDR\tsummit_strand\n";
    of
            << "\n#region_chr\tregion_start\tregion_end\tregion_ID\tregion_pvalue\tregion_strand\n";
    of_raw
            << "\n#region_chr\tregion_start\tregion_end\tregion_ID\tregion_summits\tregion_pvalue\tregion_fdr\tregion_strand\tregion_treads\tregion_creads\n";
    pritrr it = detector->_resultRegions.begin();
    for (; it != detector->_resultRegions.end(); it++) {

        foreach(called_peak pk , it->second) {
            of_raw << it->first << "\t" << pk.first << "\t" << pk.second
                    << "\tranger";
            if (pk.q <= option.getFdrCutOff()) {
                of_raw << "_fdrPassed_" << fdr_passed;
            } else {
                of_raw << "_fdrFailed_" << fdr_failed;
            }
            of_raw << "_pval_" << pk.p << "_fdr_" << pk.q;
            of_raw << "\t";
            vector<uint32_t>::iterator sit = pk.summits.begin();
            for (; sit != pk.summits.end(); sit++) {
                of_raw << *sit << "_";
                of_smt << it->first << "\t" << *sit << "\t" << (*sit) + 1
                        << "\tranger_region_" << pk.first << "_" << pk.second
                        << "_pval_" << pk.p;
                if (pk.q <= option.getFdrCutOff()) {
                    of_smt << "_fdrPassed_" << fdr_passed;
                } else {
                    of_smt << "_fdrFailed_" << fdr_failed;
                }

                of_smt << "\t" << pk.q << "\t+\n";
            }

            of_raw << "\t" << pk.p << "\t" << pk.q << "\t+\t" << pk.treads
                    << "\t" << pk.creads << "\n";

            of << it->first << "\t" << pk.first << "\t" << pk.second
                    << "\tranger";
            if (pk.q <= option.getFdrCutOff()) {
                of << "_fdrPassed_" << fdr_passed++;
            } else {
                of << "_fdrFailed_" << fdr_failed++;
            }
            of << "_pval_" << pk.p << "_fdr_" << pk.q << "\t" << pk.q
                    << "\t+\n";
        }
    }
}

void getParser(peakranger_cmd_option_parser & option,
        boost::shared_ptr<readsParser> & parser) {
    if (option.getFormat() == cmd_option_parser::format_bowtie) {
        parser = make_shared<bowtieParser>();
    } else if (option.getFormat() == cmd_option_parser::format_sam) {
        parser = make_shared<samParser>();
    } else if (option.getFormat() == cmd_option_parser::format_bed) {
        parser = make_shared<bedParser>();
    } else if (option.getFormat() == cmd_option_parser::format_bam) {
        parser = make_shared<bamParser>();
    } else {
        string str("The specified format ");
        str += option.getFormat();
        str += " has not been implemented yet.\n";
        throw not_in_range(str.c_str());
    }

}

void outputWig(peakranger_cmd_option_parser & option,
        boost::shared_ptr<wiggle_reporter> wig, Reads & treads,
        Reads & creads) {
    string ga;
    if (!(option.getNowig())) {

        ga = option.getTreat_wig_file();
        wig->setReadextlength(option.getExt_length());
        wig->setReadlength(treads.getReadlength());
        wig->setWiggleName(ga);
        if (option.getVerboseRequested())
            cout << " Exporting wiggle file:   treatment" << "\n";

        if (option.isSplit()) {
            wig->split_export_wiggle(treads, ga.c_str());
        } else {
            wig->export_wiggle(treads, ga.c_str());
        }
        if (option.getVerboseRequested())
            cout << "                          finished" << "\n";

        if (option.getVerboseRequested())
            cout << " Exporting wiggle file:   control" << "\n";

        ga = option.getControl_wig_file();
        wig->setReadextlength(option.getExt_length());
        wig->setReadlength(creads.getReadlength());
        if (option.isSplit()) {
            wig->split_export_wiggle(creads, ga.c_str());
        } else {
            wig->export_wiggle(creads, ga.c_str());
        }
        if (option.getVerboseRequested())
            cout << "                          finished" << "\n";

    }
}

void parseReads(peakranger_cmd_option_parser& option, string readsfile,
        boost::shared_ptr<readsParser>& parser, Reads& treads) {

    if (option.getChrtableSpecified()) {
        vector<string> chrs_to_parse = option.getChrs_to_parse();
        parser->parse(treads, readsfile, chrs_to_parse);
    } else {
        parser->parse(treads, readsfile);
    }

}
}

int ccat_main(int argc, char** argv) {

    SET_LOG_FILE("newdata.log");SET_LOG_LEVEL("INFO");LOG_DEBUG1("\n\n************Starting an new round***********\n\n");
#ifndef DEBUG
    try {
#endif
        peakranger_cmd_option_parser option(argc, argv);
        option.parse();
        utils::Tracer tracer(cout, option.getVerboseRequested());
        if (option.getVerboseRequested()) {
            option.print_option(cout);
        }
        boost::shared_ptr<readsParser> parser;
        getParser(option, parser);
        boost::shared_ptr<region_detector> detector = make_shared<ccat>();
        boost::shared_ptr<result_reporter> reporter = make_shared<
                bed6_result_reporter>();
        boost::shared_ptr<wiggle_reporter> wig = make_shared<JT_wiggle_file>();
        wig->use_default_setting();

        Reads treads, creads;
        parseReads(option, option.getTreat_file(), parser, treads);
        tracer << "Reads statistics:\n";
        tracer << " Treatment reads +:       " << treads.pos_reads.size()
                << "\n";
        tracer << " Treatment reads -:       " << treads.neg_reads.size()
                << "\n";

        parseReads(option, option.getControl_file(), parser, creads);
        tracer << " Control reads +:         " << creads.pos_reads.size()
                << "\n";
        tracer << " Control reads -:         " << creads.neg_reads.size()
                << "\n";
        outputWig(option, wig, treads, creads);
        tracer << " Verifying reads...\n";
        reads_tools::verify_and_correct_Reads_both_strands(treads, creads);
        tracer << "Reads statistics after correction:\n";
        tracer << " Treatment reads +:       " << treads.pos_reads.size()
                << "\n";
        tracer << " Treatment reads -:       " << treads.neg_reads.size()
                << "\n";
        tracer << " Control reads +:         " << creads.pos_reads.size()
                << "\n";
        tracer << " Control reads -:         " << creads.neg_reads.size()
                << "\n";
        if (treads.size() < 1) {
            tracer
                    << "\nNo reads were found in the treatment data. Ranger must stop here.\n\n";
            exit(0);
        }
        if (creads.size() < 1) {
            tracer
                    << "\nNo reads were found in the control data. Ranger must stop here.\n\n";
            exit(0);
        }
        {
            tracer << "\n Calling peaks...\n" << "\n";
            string ga = (option.getOutput_file() + "_raw");
            detector->detectSummits(treads, creads, option);
        }

        size_t fdr_passed = 0;
        size_t fdr_failed = 0;
        OutputResults(option, detector, fdr_passed, fdr_failed);
        tracer << "\nTotal regions discovered:\t" << fdr_failed + fdr_passed;
        tracer << "\nTotal regions passed FDR cutoff:\t" << fdr_passed << "\n";
        if (option.needHtml()) {
            tracer << "\n Generating reports:\n";
            chipseq_html_reporter rptr;
            rptr.setRegionLength(option.getHtmlRegionLength());
            rptr.generate_report(treads, creads, detector->_resultRegions,
                    option);
        }
        tracer << "\nProgram finished.\n";
        return 0;
#ifndef DEBUG
    } catch (boost::program_options::multiple_occurrences& e) {
        cout << "Fatal: Some options were specified more than once.\n";
        exit(1);
    } catch (std::bad_alloc &e) {
        cout << "Fatal: Not enough memory. std::bad_alloc\n";
        exit(1);
    } catch (std::exception &e) {
        cout << "Fatal: " << e.what() << "\n";
        exit(1);
    }

    catch (RangerException &e) {
        cout << "\nFatal: ";
        e.debugPrint();
        cout << "\n";
        exit(1);
    } catch (...) {
        cout << "Unknown error" << endl;
        exit(1);
    }
#endif
}
